package main

import (
	"bufio"
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"golang.org/x/tools/go/ast/astutil"
)

const tmpl = `
func init() {
	var __privateKeyObfuscator = []byte{
		{{- range .PrivateKey }}
		{{ . }}
		{{- end}}
	}
	var __nonceObfuscator = []byte{
		{{- range .Nonce }}
		{{ . }}
		{{- end}}
	}

	block, err := aes.NewCipher(__privateKeyObfuscator)
	if err != nil {
		panic(err)
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err)
	}

	{{- range .Variables }}
	{
		{{ if .IsArray -}}
		var __{{ .Name }} = [][]byte{
		{{- range $i, $e := .Values }}
			{
				{{- range $e }}
				{{ . }}
				{{- end}}
			},
		{{- end}}
		}
		ret := make([]string, 0, len(__{{ .Name }}))
		for _, v := range __{{ .Name }} {
			plaintext, err := aesgcm.Open(nil, __nonceObfuscator, v, nil)
			if err != nil {
				panic(err)
			}
			ret = append(ret, string(plaintext))
		}
		{{ .Name }} = ret
		{{- else -}}
		var __{{ .Name }} = []byte{
			{{- range ( index .Values 0) }}
			{{ . }}
			{{- end}}
		}
		plaintext, err := aesgcm.Open(nil, __nonceObfuscator, __{{ .Name }}, nil)
		if err != nil {
			panic(err)
		}
		{{ .Name }} = string(plaintext)
		{{- end }}
	}
	{{- end -}}
	{{ .InitCode -}}
}
`

type variable struct {
	Name    string
	Values  [][]string
	IsArray bool
}

var (
	_output   = flag.String("output", "", "output file name; default stdout")
	_filename = flag.String("filename", "", "name of the file to be obfuscate")
)

func usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tstrobfus -filename <file>.go\n")
	fmt.Fprintf(os.Stderr, "For more information, see:\n")
	fmt.Fprintf(os.Stderr, "\thttp://github.com/znly/strobfus\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func checkArgs() {
	flag.Usage = usage
	flag.Parse()

	if *_filename == "" {
		usage()
		os.Exit(1)
	}
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("strobfus: ")

	checkArgs()

	content, err := ioutil.ReadFile(*_filename)
	if err != nil {
		log.Fatal(err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", content, 0)
	if err != nil {
		log.Fatalf("unable to parse %s: %v", *_filename, err)
	}

	key, nonce, aesgcm, err := setupAES()
	if err != nil {
		log.Fatal(err)
	}

	initCode := ""
	variables := make([]*variable, 0)
	astutil.Apply(f, func(c *astutil.Cursor) bool {
		switch typ := c.Node().(type) {
		case *ast.GenDecl:
			for _, spec := range typ.Specs {
				if vSpec, ok := spec.(*ast.ValueSpec); ok {
					for _, v := range vSpec.Values {
						obfuscated := &variable{Name: vSpec.Names[0].Name}
						switch real := v.(type) {
						case *ast.BasicLit:
							if real.Kind == token.STRING && len(real.Value) > 2 {
								obfuscated.Values = [][]string{bytesToHex(aesgcm.Seal(nil, nonce, []byte(real.Value[1:len(real.Value)-1]), nil))}
								variables = append(variables, obfuscated)

								// vSpec.Comment = &ast.CommentGroup{List: []*ast.Comment{{Text: " // " + real.Value}}} // doesn't work yet
								real.Value = `""`
							}
						case *ast.CompositeLit:
							for _, elt := range real.Elts {
								if inner, ok := elt.(*ast.BasicLit); ok && inner.Kind == token.STRING && len(inner.Value) > 2 {
									obfuscated.IsArray = true
									obfuscated.Values = append(obfuscated.Values, bytesToHex(aesgcm.Seal(nil, nonce, []byte(inner.Value[1:len(inner.Value)-1]), nil)))
								}
							}
							variables = append(variables, obfuscated)
							real.Elts = []ast.Expr{}
						}
					}
				}
			}
		case *ast.FuncDecl:
			if typ.Name.Name == "init" {
				from, to := int(typ.Body.Lbrace), int(typ.Body.Rbrace)
				initCode = string(content[from : to-1])
				c.Delete()
			}
		}
		return true
	}, nil)
	astutil.AddImport(fset, f, "crypto/aes")
	astutil.AddImport(fset, f, "crypto/cipher")

	config := &printer.Config{}
	var buf bytes.Buffer

	err = config.Fprint(&buf, fset, f)
	if err != nil {
		log.Fatal(err)
	}

	vars, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	out := (io.Writer)(os.Stdout) // default output
	if *_output != "" {
		wd, err := os.Getwd()
		if err != nil {
			log.Fatal(err)
		}
		out, err = os.Create(filepath.Join(wd, *_output))
		if err != nil {
			log.Fatal(err)
		}
	}

	writer := bufio.NewWriter(out)
	writer.WriteString(`// Code generated by "strobfus"; DO NOT EDIT.
// source: https://github.com/znly/strobfus/blob/master/main.go

`)
	writer.WriteString(string(vars))

	tmpl, err := template.New("").Parse(tmpl)
	if err != nil {
		log.Fatal(err)
	}

	err = tmpl.Execute(writer, struct {
		PrivateKey, Nonce []string
		Variables         []*variable
		InitCode          string
	}{
		PrivateKey: bytesToHex(key),
		Nonce:      bytesToHex(nonce),
		Variables:  variables,
		InitCode:   initCode,
	})
	if err != nil {
		log.Fatal(err)
	}

	writer.Flush()
}

func setupAES() (key, nonce []byte, aesgcm cipher.AEAD, err error) {
	key = make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		return nil, nil, nil, err
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, nil, nil, err
	}
	nonce = make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, nil, nil, err
	}
	aesgcm, err = cipher.NewGCM(block)
	if err != nil {
		return nil, nil, nil, err
	}
	return key, nonce, aesgcm, nil
}

func bytesToHex(value []byte) []string {
	ret := []string{}

	for len(value) > 0 {
		n := 16
		if n > len(value) {
			n = len(value)
		}

		s := ""
		for i, c := range value[:n] {
			if i == 0 {
				s += fmt.Sprintf("0x%02x,", c)
			} else {
				s += fmt.Sprintf(" 0x%02x,", c)
			}
		}
		ret = append(ret, s)
		value = value[n:]
	}
	return ret
}

// for _, decl := range f.Decls {
// 	if gen, ok := decl.(*ast.GenDecl); ok && gen.Tok == token.VAR {
// 		fmt.Printf("  var -> %+v\n", gen)
// 		for _, spec := range gen.Specs {
// 			if value, ok := spec.(*ast.ValueSpec); ok && value.Type == nil {
// 				fmt.Printf("   spec -> %+v\n", value)
// 				// value.Values = append(value.Values, &ast.BasicLit{Kind: token.STRING, Value: "toto"})
// 				for _, v := range value.Values {
// 					switch real := v.(type) {
// 					case *ast.BasicLit:
// 						if real.Kind == token.STRING {
// 							fmt.Printf("      string value -> %+v\n", real)
// 						}
// 					case *ast.CompositeLit:
// 						fmt.Printf("      composite value -> %+T\n", real.Type.(*ast.ArrayType).Elt)
// 						for _, elts := range real.Elts {
// 							fmt.Printf("        elts -> %+T\n", elts)
// 							if inner, ok := elts.(*ast.BasicLit); ok {
// 								fmt.Printf("          string value -> %+v\n", inner)
// 							}
// 						}
// 					default:
// 					}
// 				}
// 			} else {
// 				fmt.Printf("   WRONGSPEC -> %+v\n", value)
// 			}
// 		}
// 	} else {
// 		fmt.Printf("  UNKNOWN -> %+v\n", decl)
// 	}
// }
